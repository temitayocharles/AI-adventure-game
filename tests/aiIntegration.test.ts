/**
 * tests/aiIntegration.test.ts
 * Integration tests for AI service, fallbacks, and all endpoints
 * Tests both Gemini success paths and fallback mechanisms
 */

import { describe, it, expect, beforeEach } from 'vitest';

// Mock types
interface AITestResult {
  endpoint: string;
  success: boolean;
  hasFallback: boolean;
  responseTime: number;
  message: string;
}

interface TestConfig {
  apiBase: string;
  timeout: number;
  testToken: string;
}

/**
 * AI Service Test Suite
 */
describe('Stage 7: AI Integration & Fallbacks', () => {
  const config: TestConfig = {
    apiBase: process.env.VITE_API_BASE || 'http://localhost:4000',
    timeout: 5000,
    testToken: 'test-jwt-token'
  };

  let results: AITestResult[] = [];

  beforeEach(() => {
    results = [];
  });

  /**
   * Test 1: Quest Generation with Fallback
   */
  describe('Test 1: Quest Generation', () => {
    it('should generate quest via Gemini or fallback', async () => {
      const startTime = Date.now();
      
      try {
        const res = await fetch(`${config.apiBase}/api/v1/ai/query`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${config.testToken}`
          },
          body: JSON.stringify({
            userId: 'test-user-1',
            promptType: 'quest',
            promptPayload: {
              worldName: 'Earthquake',
              difficulty: 'medium'
            }
          })
        });

        const responseTime = Date.now() - startTime;
        const data = await res.json();

        expect(res.status).toBeLessThan(400);
        expect(data.reply).toBeDefined();
        
        const quest = JSON.parse(data.reply);
        expect(quest.title).toBeDefined();
        expect(quest.description).toBeDefined();
        expect(quest.reward).toBeDefined();

        results.push({
          endpoint: 'POST /api/v1/ai/query (quest)',
          success: true,
          hasFallback: data.fallback || false,
          responseTime,
          message: data.fallback ? 'Served from fallback' : 'Generated by Gemini'
        });
      } catch (error) {
        results.push({
          endpoint: 'POST /api/v1/ai/query (quest)',
          success: false,
          hasFallback: false,
          responseTime: Date.now() - startTime,
          message: `Error: ${error}`
        });
        throw error;
      }
    });
  });

  /**
   * Test 2: NPC Chat with Personality Fallback
   */
  describe('Test 2: NPC Chat', () => {
    const npcs = ['sprinkle', 'elder', 'merchant', 'guardian'];

    npcs.forEach(npc => {
      it(`should chat with ${npc} NPC via Gemini or fallback`, async () => {
        const startTime = Date.now();

        try {
          const res = await fetch(`${config.apiBase}/api/v1/ai/npc-chat`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${config.testToken}`
            },
            body: JSON.stringify({
              userId: 'test-user-1',
              npcId: npc,
              message: 'How can I beat this level?'
            })
          });

          const responseTime = Date.now() - startTime;
          const data = await res.json();

          expect(res.status).toBeLessThan(400);
          expect(data.reply).toBeDefined();
          expect(typeof data.reply).toBe('string');
          expect(data.reply.length).toBeGreaterThan(0);

          results.push({
            endpoint: `POST /api/v1/ai/npc-chat (${npc})`,
            success: true,
            hasFallback: data.fallback || false,
            responseTime,
            message: data.fallback ? 'Served from fallback' : 'Generated by Gemini'
          });
        } catch (error) {
          results.push({
            endpoint: `POST /api/v1/ai/npc-chat (${npc})`,
            success: false,
            hasFallback: false,
            responseTime: Date.now() - startTime,
            message: `Error: ${error}`
          });
          throw error;
        }
      });
    });
  });

  /**
   * Test 3: Adaptive Difficulty with Heuristic Fallback
   */
  describe('Test 3: Adaptive Difficulty', () => {
    const scenarios = [
      { completionTime: 25, attempts: 1, expected: 'hard' },
      { completionTime: 60, attempts: 2, expected: 'medium' },
      { completionTime: 200, attempts: 5, expected: 'easy' }
    ];

    scenarios.forEach(scenario => {
      it(`should adapt difficulty for scenario: ${scenario.completionTime}s, ${scenario.attempts} attempts`, async () => {
        const startTime = Date.now();

        try {
          const res = await fetch(`${config.apiBase}/api/v1/ai/adaptive-difficulty`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${config.testToken}`
            },
            body: JSON.stringify({
              userId: 'test-user-1',
              levelId: 'level-1',
              completionTime: scenario.completionTime,
              attempts: scenario.attempts
            })
          });

          const responseTime = Date.now() - startTime;
          const data = await res.json();

          expect(res.status).toBeLessThan(400);
          expect(data.reply).toBeDefined();
          expect(data.difficulty).toBeDefined();
          expect(['easy', 'medium', 'hard']).toContain(data.difficulty);

          results.push({
            endpoint: `POST /api/v1/ai/adaptive-difficulty`,
            success: true,
            hasFallback: data.fallback || false,
            responseTime,
            message: `Difficulty: ${data.difficulty} (${data.fallback ? 'heuristic' : 'AI-adapted'})`
          });
        } catch (error) {
          results.push({
            endpoint: 'POST /api/v1/ai/adaptive-difficulty',
            success: false,
            hasFallback: false,
            responseTime: Date.now() - startTime,
            message: `Error: ${error}`
          });
          throw error;
        }
      });
    });
  });

  /**
   * Test 4: Dynamic Level Generation with Fallback
   */
  describe('Test 4: Dynamic Level Generation', () => {
    it('should generate level via Gemini or fallback', async () => {
      const startTime = Date.now();

      try {
        const res = await fetch(`${config.apiBase}/api/v1/ai/generate-level`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${config.testToken}`
          },
          body: JSON.stringify({
            userId: 'test-user-1',
            difficulty: 'medium',
            seed: 'earthquake-level-5'
          })
        });

        const responseTime = Date.now() - startTime;
        const data = await res.json();

        expect(res.status).toBeLessThan(400);
        expect(data.platforms).toBeDefined();
        expect(Array.isArray(data.platforms)).toBe(true);
        expect(data.goal).toBeDefined();
        expect(data.platforms.length).toBeGreaterThan(0);

        results.push({
          endpoint: 'POST /api/v1/ai/generate-level',
          success: true,
          hasFallback: data.generated === false,
          responseTime,
          message: `Generated ${data.platforms.length} platforms (${data.generated === false ? 'procedural' : 'AI'})`
        });
      } catch (error) {
        results.push({
          endpoint: 'POST /api/v1/ai/generate-level',
          success: false,
          hasFallback: false,
          responseTime: Date.now() - startTime,
          message: `Error: ${error}`
        });
        throw error;
      }
    });
  });

  /**
   * Test 5: Rate Limiting & Error Handling
   */
  describe('Test 5: Rate Limiting & Error Handling', () => {
    it('should respect rate limits gracefully', async () => {
      const requests = [];
      
      // Send 5 requests rapidly
      for (let i = 0; i < 5; i++) {
        requests.push(
          fetch(`${config.apiBase}/api/v1/ai/query`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${config.testToken}`
            },
            body: JSON.stringify({
              userId: `test-user-${i}`,
              promptType: 'quest',
              promptPayload: { worldName: 'Earthquake' }
            })
          })
        );
      }

      const responses = await Promise.all(requests);
      const statuses = responses.map(r => r.status);

      // At least most should succeed
      const successCount = statuses.filter(s => s < 400).length;
      expect(successCount).toBeGreaterThanOrEqual(4);

      results.push({
        endpoint: 'Rate Limiting Test',
        success: successCount >= 4,
        hasFallback: true,
        responseTime: 0,
        message: `${successCount}/5 requests succeeded`
      });
    });

    it('should handle invalid tokens gracefully', async () => {
      const startTime = Date.now();

      try {
        const res = await fetch(`${config.apiBase}/api/v1/ai/query`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer invalid-token'
          },
          body: JSON.stringify({
            userId: 'test-user-1',
            promptType: 'quest',
            promptPayload: { worldName: 'Earthquake' }
          })
        });

        const responseTime = Date.now() - startTime;

        // Should return 401 or error
        expect(res.status).toBeGreaterThanOrEqual(400);

        results.push({
          endpoint: 'Auth Error Handling',
          success: true,
          hasFallback: false,
          responseTime,
          message: `Correctly rejected invalid token (HTTP ${res.status})`
        });
      } catch (error) {
        results.push({
          endpoint: 'Auth Error Handling',
          success: false,
          hasFallback: false,
          responseTime: Date.now() - startTime,
          message: `Error: ${error}`
        });
      }
    });
  });

  /**
   * Test 6: Fallback Coverage
   */
  describe('Test 6: Fallback Coverage', () => {
    it('should have fallbacks for all worlds', async () => {
      const worlds = ['Earthquake', 'Tsunami', 'Volcano', 'Desert'];
      const fallbackTests = [];

      for (const world of worlds) {
        const test = fetch(`${config.apiBase}/api/v1/ai/query`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${config.testToken}`
          },
          body: JSON.stringify({
            userId: 'test-user-fallback',
            promptType: 'quest',
            promptPayload: { worldName: world }
          })
        })
          .then(res => res.json())
          .then(data => ({
            world,
            success: !!data.reply,
            fallback: data.fallback || false
          }));

        fallbackTests.push(test);
      }

      const fallbackResults = await Promise.all(fallbackTests);

      // All should succeed
      fallbackResults.forEach(result => {
        expect(result.success).toBe(true);
      });

      results.push({
        endpoint: 'Fallback Coverage',
        success: fallbackResults.every(r => r.success),
        hasFallback: true,
        responseTime: 0,
        message: `All ${worlds.length} worlds have fallbacks`
      });
    });
  });

  /**
   * Print test results
   */
  afterAll(() => {
    console.log('\n=== AI Integration Test Results ===\n');
    results.forEach(result => {
      const status = result.success ? '✅' : '❌';
      console.log(`${status} ${result.endpoint}`);
      console.log(`   Response Time: ${result.responseTime}ms`);
      console.log(`   Has Fallback: ${result.hasFallback ? 'Yes' : 'No'}`);
      console.log(`   Message: ${result.message}\n`);
    });

    const successCount = results.filter(r => r.success).length;
    const fallbackCount = results.filter(r => r.hasFallback).length;
    console.log(`\nSummary: ${successCount}/${results.length} tests passed`);
    console.log(`Fallback usage: ${fallbackCount} tests`);
  });
});
